メモリ管理
=================

メモリ管理に関して、考慮すべき重要な点がいくつかあります。
OWASP のガイドラインに基づき、アプリケーションを保護するためには、まずユーザーの入出力に関連する措置を講じる必要があります。悪意のあるコンテンツが許可されないようにする必要があります。
より詳細な概要は、[入力のバリデーション][1]および[出力エンコーディング][2]のセクションをご覧ください。

バッファ境界のチェックも、メモリ管理の重要な側面です。
コピーするバイト数を受け取る関数を扱う場合。C 言語では通常、コピー先の配列の大きさをチェックし、割り当てられた領域を超えて書き込まないようにする必要があります。

Go では、`String` のようなデータ型は NULL 終端ではありません。`String` の場合、そのヘッダは以下の情報で構成されます。


```go
type StringHeader struct {
    Data uintptr
    Len  int
}
```

そうだとしても、境界のチェックは行わなければなりません（たとえば、ループするとき）。
もし、設定された境界を越えてしまうと、Go は `Panic` してしまいます。

以下は簡単な例です。

```go
func main() {
    strings := []string{"aaa", "bbb", "ccc", "ddd"}
    // Our loop is not checking the MAP length -> BAD
    for i := 0; i < 5; i++ {
        if len(strings[i]) > 0 {
            fmt.Println(strings[i])
        }
    }
}
```

Output:

```
aaa
bbb
ccc
ddd
panic: runtime error: index out of range
```

アプリケーションがリソースを使用する場合、ガベージコレクタだけに頼るのではなく、リソースがクローズされたことをチェックする必要があります。
これは、コネクションオブジェクトやファイルハンドラなどを扱うときに適用できます。
Go では、これらのアクションを実行するために `defer` が利用できます。`defer` 内の命令は、ほかの関数が実行を終了したときにのみ実行されます。

```go
defer func() {
    // Our cleanup code here
}
```

`defer` に関するより詳しい情報は、このドキュメントの [エラー処理][3] のセクションにあります。

また、脆弱であることが知られている関数の使用も避けるべきです。
Go では、`Unsafe` パッケージにこれらの関数が含まれています。これらの関数は、プロダクション環境やプロダクション環境で使われるパッケージでは使用しないでください。
`Testing` パッケージも同様です。

一方、メモリの解放はガベージコレクタによって処理されるため、心配する必要はありません。
手動でメモリ割り当てを解放できますが推奨しません。

[Go言語のGitHub](https://github.com/golang/go/issues/13761)を引用します。

> もし本当にGoでメモリを手動で管理したいのであれば、自力で
> syscall.Mmap や cgo malloc/free をベースにした独自のメモリアロケータを実装してください。
> GC を長期間無効にすることは、Go のような並行処理言語では一般に悪手です。Go の GC はこれから先もずっと改善されていくことでしょう。

[1]: ../input-validation/README.md
[2]: ../output-encoding/README.md
[3]: ../error-handling-logging/README.md
